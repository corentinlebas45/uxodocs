name: test-deploy

on:
  push:
    branches:
      - test
      - test-**     # ex: test-fast2-v2, test-arender-v1, ...
  workflow_dispatch:

permissions:
  contents: write

concurrency:
  group: test-deploy
  cancel-in-progress: false

jobs:
  aggregate:
    runs-on: ubuntu-latest

    steps:
      - name: Checkout destination branch (test)
        uses: actions/checkout@v4
        with:
          ref: test
          fetch-depth: 0

      - name: Setup Node
        uses: actions/setup-node@v4
        with:
          node-version: "20"

      - name: Fetch all branches
        run: git fetch --all --prune

      - name: Aggregate docs branches into docs/<product>/vX
        shell: bash
        run: |
          set -euo pipefail

          # Produits connus (ajuste si besoin)
          PRODUCTS=("arender" "fast2" "flower")
          # mapping pour noms de branches différents des dossiers
          map_branch_to_product() {
            case "$1" in
              flowerdocs) echo "flower" ;;
              *)          echo "$1" ;;
            esac
          }

          # 1) On efface seulement les anciens dossiers v* sans toucher les index "courants"
          for p in "${PRODUCTS[@]}"; do
            if [ -d "docs/$p" ]; then
              find "docs/$p" -mindepth 1 -maxdepth 1 -type d -name 'v*' -print0 | xargs -0 -r rm -rf
            fi
          done

          # 2) Lister les branches test-*-v*
          mapfile -t BRANCHES < <(git for-each-ref --format='%(refname:short)' refs/remotes/origin/test-* | sort)

          mkdir -p .worktrees
          for remote_ref in "${BRANCHES[@]}"; do
            br="${remote_ref#origin/}"    # ex: test-fast2-v2
            raw_product=$(sed -E 's|^test-([^/-]+)-v[0-9]+$|\1|' <<< "$br")
            version=$(sed -E 's|^test-[^/-]+-(v[0-9]+)$|\1|' <<< "$br")
            product="$(map_branch_to_product "$raw_product")"

            # Skip si parsing raté
            if [[ -z "$product" || -z "$version" ]]; then
              echo "Ignore: $br (impossible d'extraire produit/version)"
              continue
            fi

            echo "→ $br  -> product=$product  version=$version"

            worktree_dir=".worktrees/$br"
            rm -rf "$worktree_dir"
            git worktree add --force "$worktree_dir" "$br"

            src_dir="$worktree_dir/docs/$product"
            if [ ! -d "$src_dir" ]; then
              echo "Avertissement: $src_dir introuvable, on ignore cette branche."
              git worktree remove --force "$worktree_dir"
              continue
            fi

            dest_dir="docs/$product/$version"
            mkdir -p "$dest_dir"

            # Copie le contenu de docs/<product> dans docs/<product>/<vX>,
            # en excluant d'éventuels sous-dossiers v* déjà présents dans la branche source.
            rsync -a --delete \
              --exclude 'v*/' \
              "$src_dir"/ "$dest_dir"/

            git worktree remove --force "$worktree_dir"
          done

          echo "Aperçu:"
          find docs -maxdepth 2 -type d -name 'v*' | sort || true

      - name: Install deps (if collectVersions needs them)
        run: npm ci --prefer-offline --no-audit --no-fund || true

      - name: Generate versions.manifest.json
        if: ${{ hashFiles('scripts/collectVersions.mjs') != '' }}
        run: node scripts/collectVersions.mjs

      - name: Commit & push aggregated docs to test
        run: |
          set -euo pipefail
          git config user.name  "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"

          git add -A
          if git diff --cached --quiet; then
            echo "Aucun changement à pousser."
            exit 0
          fi

          git commit -m "chore(test-deploy): aggregate docs into docs/<product>/<vX> [skip ci]"
          git push origin HEAD:test