name: Sync product docs into test

on:
  push:
    branches:
      - 'test'
      - 'test-*'   # ex: test-fast2-v1
  workflow_dispatch:

permissions:
  contents: write

jobs:
  sync:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Detect mode (aggregate vs single-branch)
        id: mode
        shell: bash
        run: |
          if [[ "${GITHUB_REF_NAME}" == "test" ]]; then
            echo "mode=aggregate" >> $GITHUB_OUTPUT
          else
            echo "mode=single" >> $GITHUB_OUTPUT
          fi

      # --------------------------
      # Mode 1: SINGLE BRANCH (test-<product>-<version>) -> push into branch test
      # --------------------------
      - name: Parse branch -> product & version
        id: parse
        if: steps.mode.outputs.mode == 'single'
        shell: bash
        run: |
          ref="${GITHUB_REF_NAME}"        # ex: test-fast2-v1
          IFS='-' read -r prefix product version <<< "$ref"
          if [[ "$prefix" != "test" || -z "$product" || -z "$version" ]]; then
            echo "Branch name must be test-<product>-<version> (e.g. test-fast2-v1)"; exit 1
          fi
          echo "product=$product" >> $GITHUB_OUTPUT
          echo "version=$version" >> $GITHUB_OUTPUT

      - name: Prepare worktree for target branch 'test'
        if: steps.mode.outputs.mode == 'single'
        shell: bash
        run: |
          git fetch origin test:test || true
          git worktree add ../worktree-test origin/test

      - name: Copy docs into versioned folder in test
        if: steps.mode.outputs.mode == 'single'
        shell: bash
        run: |
          set -euo pipefail
          product='${{ steps.parse.outputs.product }}'
          version='${{ steps.parse.outputs.version }}'
          src_file="docs/${product}/index.md"
          if [[ ! -f "$src_file" ]]; then
            echo "Expected ${src_file} in source branch"; exit 1
          fi
          target_root="../worktree-test/docs/${product}"
          target_ver="${target_root}/${version}"
          mkdir -p "$target_ver"
          cp "$src_file" "${target_ver}/index.md"

          # (Re)générer l'index du produit avec les versions détectées
          mkdir -p "$target_root"
          mapfile -t versions < <(find "$target_root" -maxdepth 1 -type d -name "v*" -printf "%f\n" | sort -V)
          {
            echo "# ${product^}"
            echo
            echo "> Pages par version"
            echo
            for v in "${versions[@]}"; do
              echo "- [${v}](./${v}/index)"
            done
            echo
            if [[ -f "${target_root}/index.base.md" ]]; then
              cat "${target_root}/index.base.md"
            else
              echo "_Créez **docs/${product}/index.base.md** pour personnaliser ce haut de page._"
            fi
          } > "${target_root}/index.md"

      - name: Commit & push to test
        if: steps.mode.outputs.mode == 'single'
        working-directory: ../worktree-test
        shell: bash
        run: |
          product='${{ steps.parse.outputs.product }}'
          version='${{ steps.parse.outputs.version }}'
          git config user.name "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"
          if ! git diff --quiet; then
            git add "docs/${product}"
            git commit -m "Sync ${product} ${version} docs from ${GITHUB_REF_NAME}"
            git push origin HEAD:test
          else
            echo "No changes to commit."
          fi

      # --------------------------
      # Mode 2: AGGREGATE (triggered by push on 'test')
      # --------------------------
      - name: Aggregate all test-* branches into current 'test'
        if: steps.mode.outputs.mode == 'aggregate'
        shell: bash
        run: |
          set -euo pipefail
          # S'assure qu'on a toutes les branches distantes
          git fetch origin "+refs/heads/*:refs/remotes/origin/*"

          # Répertoire de travail = branche test déjà checkout
          mkdir -p docs

          # Liste toutes les branches test-*-*
          mapfile -t branches < <(git for-each-ref --format='%(refname:short)' refs/remotes/origin | grep '^origin/test-' | sort)
          if [[ ${#branches[@]} -eq 0 ]]; then
            echo "Aucune branche origin/test-* trouvée. Rien à agréger."
          fi

          # Pour chaque branche, extraire product & version et copier le index.md
          declare -A touched_products=()
          for b in "${branches[@]}"; do
            bn="${b#origin/}"               # ex: test-fast2-v1
            IFS='-' read -r prefix product version <<< "$bn"
            if [[ "$prefix" != "test" || -z "$product" || -z "$version" ]]; then
              echo "Skip $bn (format inattendu)"; continue
            fi

            # Vérifie si le fichier source existe dans cette branche
            if git cat-file -e "${b}:docs/${product}/index.md" 2>/dev/null; then
              target_ver_dir="docs/${product}/${version}"
              mkdir -p "$target_ver_dir"
              git show "${b}:docs/${product}/index.md" > "${target_ver_dir}/index.md"
              touched_products["$product"]=1
              echo "OK: ${bn} -> ${target_ver_dir}/index.md"
            else
              echo "WARN: ${bn} n'a pas docs/${product}/index.md, on ignore."
            fi
          done

          # (Re)génère l'index pour chaque produit ayant au moins une version
          for product_dir in docs/*; do
            [[ -d "$product_dir" ]] || continue
            product="$(basename "$product_dir")"

            # Ne régénère que s'il y a des dossiers v*
            mapfile -t versions < <(find "$product_dir" -maxdepth 1 -type d -name "v*" -printf "%f\n" | sort -V)
            [[ ${#versions[@]} -gt 0 ]] || continue

            {
              echo "# ${product^}"
              echo
              echo "> Pages par version"
              echo
              for v in "${versions[@]}"; do
                echo "- [${v}](./${v}/index)"
              done
              echo
              if [[ -f "${product_dir}/index.base.md" ]]; then
                cat "${product_dir}/index.base.md"
              else
                echo "_Créez **docs/${product}/index.base.md** pour personnaliser ce haut de page._"
              fi
            } > "${product_dir}/index.md"
          done

      - name: Commit & push aggregated changes (on test)
        if: steps.mode.outputs.mode == 'aggregate'
        shell: bash
        run: |
          git config user.name "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"
          if ! git diff --quiet; then
            git add docs
            git commit -m "Aggregate all test-* branches into test"
            git push
          else
            echo "No changes to commit."
          fi
