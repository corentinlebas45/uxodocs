import fs from 'fs';
import path from 'path';
import type { SidebarsConfig, SidebarItem } from '@docusaurus/plugin-content-docs';

const DOCS_DIR = path.join(__dirname, 'docs');
const PRODUCTS = ['fast2', 'arender', 'flowerdocs'] as const;

const exists = (p: string) => fs.existsSync(p);
const hasIndex = (dir: string) =>
  exists(path.join(dir, 'index.md')) || exists(path.join(dir, 'index.mdx'));
const listDirs = (dir: string) =>
  exists(dir) ? fs.readdirSync(dir, { withFileTypes: true }).filter(d => d.isDirectory()).map(d => d.name) : [];
const titleCase = (s: string) => (s ? s[0].toUpperCase() + s.slice(1) : s);

// üëâ d√©tecte s'il y a AU MOINS un .md/.mdx (r√©cursif)
function hasDocsRecursive(dir: string): boolean {
  if (!exists(dir)) return false;
  const entries = fs.readdirSync(dir, { withFileTypes: true });
  for (const e of entries) {
    const p = path.join(dir, e.name);
    if (e.isDirectory()) {
      if (hasDocsRecursive(p)) return true;
    } else if (/\.(md|mdx)$/i.test(e.name)) {
      return true;
    }
  }
  return false;
}

function buildProductCategory(product: string): SidebarItem | null {
  const productDir = path.join(DOCS_DIR, product);
  if (!hasIndex(productDir)) return null;

  const items: SidebarItem[] = [];

  // 1) Index
  items.push({
    type: 'doc',
    id: `${product}/index`,
    label: 'Index',
    key: `${product}-index`,
  });

  // 2) Fichiers racine (fr√®res de index) au m√™me niveau
  const rootDocs = fs
    .readdirSync(productDir)
    .filter((n) => n.match(/\.(md|mdx)$/i) && !/^index\.mdx?$/i.test(n))
    .map((n) => n.replace(/\.(md|mdx)$/i, ''))
    .sort((a, b) => a.localeCompare(b, undefined, { numeric: true, sensitivity: 'base' }));

  for (const base of rootDocs) {
    items.push({
      type: 'doc',
      id: `${product}/${base}`,
      key: `${product}-root-${base}`,
    });
  }

  // 3) Cat√©gories racine (exclut v*) ‚Äî seulement si elles contiennent des docs
  const rootDirs = listDirs(productDir)
    .filter((name) => !/^v\d+/i.test(name))
    .sort((a, b) => a.localeCompare(b, undefined, { numeric: true, sensitivity: 'base' }));

  for (const dir of rootDirs) {
    const full = path.join(productDir, dir);
    if (!hasDocsRecursive(full)) {
      // skip dossiers ‚Äúassets‚Äù, ‚Äúdocuments‚Äù, etc. sans .md/.mdx
      continue;
    }
    items.push({
      type: 'category',
      label: dir,
      collapsed: true,
      key: `${product}-cat-${dir}`,
      items: [{ type: 'autogenerated', dirName: `${product}/${dir}` }],
    });
  }

  // 4) Versions (v1, v2, ‚Ä¶) ‚Äî seulement si index pr√©sent
  const versions = listDirs(productDir)
    .filter((name) => /^v\d+/i.test(name) && hasIndex(path.join(productDir, name)))
    .sort((a, b) => a.localeCompare(b, undefined, { numeric: true, sensitivity: 'base' }));

  for (const v of versions) {
    items.push({
      type: 'category',
      label: v.toLowerCase(),
      collapsed: true,
      key: `${product}-${v.toLowerCase()}`,
      items: [{ type: 'autogenerated', dirName: `${product}/${v}` }],
    });
  }

  return {
    type: 'category',
    label: titleCase(product),
    collapsed: false,
    key: `cat-${product}`,
    items,
  };
}

const sidebarItems: SidebarItem[] = [];

// Intro (si pr√©sente)
if (exists(path.join(DOCS_DIR, 'intro.md')) || exists(path.join(DOCS_DIR, 'intro.mdx'))) {
  sidebarItems.push({ type: 'doc', id: 'intro', label: 'Introduction', key: 'intro' });
}

// Un bloc par produit whitelist√©
for (const p of PRODUCTS) {
  const cat = buildProductCategory(p);
  if (cat) sidebarItems.push(cat);
}

const sidebars: SidebarsConfig = { docs: sidebarItems };
export default sidebars;